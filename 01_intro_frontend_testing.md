# Зачем вообще тестировать фронтенд?

> ✍️ Пишу боевые юнит-тесты для React уже 4 года: не «todo-list», а крупный продукт с CI/CD. Знаю школы тестирования, гонял Enzyme и RTL — поэтому создал свою библиотеку `shallowly`. Пишу код вслепую в Neovim и уверен: времени «нет» только у тех, кто кликает мышью в `идехе` вместо того, чтобы писать тесты.

## От «запустилось в браузере» до зелёного CI

На заре когда реакт был еще зеленым а бэкбон уходил в архив модные парни говорили за тестирование. вернее я впервые услышал про это.

Когда-то мой чек-лист «готово ли фиче» выглядел просто: открыть браузер, нажать пару кнопок, убедиться, что не упало в консоли, и делать merge. В тот момент проект жил быстро, но отхватывал баги ещё быстрее. Каждый хот-фикс тянул за собой новый хот-фикс, а я начал бояться рефакторинга.

Перелом настал, когда за ночь пришлось откатывать релиз из-за одного пропущенного null-чека. Тогда мы ввели первые юнит-тесты — и оказалось, что они:

- ловят очевидные ошибки ещё до браузера;
- дают смелость вырезать мёртвый код;
- документируют намерение функции лучше комментариев.

Сейчас в репозитории 3 000+ тестов, а CI за 2–3 минуты говорит, можно ли деплоить. Да, писать тесты — «дорого», но постоянно чинить баги дороже.

## Как развивалось тестирование UI

1. **Скриншот + snapshot**. «Если diff не красный — всё хорошо». Быстро, но шумно: меняешь паддинг — тест красный.
2. **Интеграционное e2e**. Прогнать юзкейс в браузере через Cypress/Playwright. Полезно для критических флоу, но медленно и хрупко.
3. **Юнит**. Изолируем компонент/функцию, подсовываем моки, получаем молниеносный фидбек.

Со временем пирамида устаканилась: много юнитов, меньше интеграционных, минимум e2e. Такой баланс даёт скорость и уверенность.

## Почему именно юниты — спойлер к следующей статье

Юниты покрывают:

- ветвления, которые сложно накликать руками;
- пограничные кейсы (0, undefined, …);
- чистую бизнес-логику без DOM.

Интеграционные нужны, но они не подскажут, где именно упала функция форматирования цены, а юнит подскажет.

---

В следующих частях разберём, как юниты ускоряют TDD, почему Enzyme был хорош, но устарел, и зачем я пишу свою `shallowly`. Следите за серией!
