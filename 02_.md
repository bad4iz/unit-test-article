# Почему именно юнит-тесты

- Что останавливает от написания юнит тестов
- Скорость выполнения и разработка TDD.
- Не тестируем функции милион раз одно и тоже.
- Нет хрупких в тестах когда окружение во вложенных компонентах меняется.
- Детерминизм и изоляция от окружения.
- Простота отладки и локализации ошибок.
- Связь с архитектурой маленьких компонент.
- Интеграция с wallaby + vibe coding
- Для чего юнит тесты
  - для фриза функционала функции (юнита ) типа в разработке чего либо показал кнопку и что бы не забыть что ты ее заинвертил.
  - ты точно понимаешь как работает твой код никаких черных ящиков в юните.
  - ни каких простыней в 1000 строк кода
  - функция чистая лаконичная все по феншую.
- для чего не подходят
  - гаратировать что приложение правильно работает

## соглашение

integration test - react tests library
unit test - enzyme (shallow render)
unit test - не понацея а один из вариантов тестирования. Они ни чего не гарантируют как и любой инструмент в плохом использовании. Но они точно подчеркнут что в юните есть проблемы если юнит тесты долго писать и тяжело поддерживать.

## Почему мы на боевом проекте пишем юнит тесты

> В нашей команде мы убедились, что юнит-тесты — это не роскошь, а необходимость для поддержания высокого качества кода в долгосрочной перспективе. Они помогают нам:

1. Уверенно вносить изменения в существующий код без страха что-то сломать
2. Поддерживать код в хорошем состоянии и улучшать его по мере необходимости
3. Облегчать отладку и локализацию ошибок
4. Улучшать качество кода и уверенность в нём

Немножко предыстории

имеем крупное проект на react

| Language   | Files    | Lines      | Code       | Comments  | Blanks    |
| ---------- | -------- | ---------- | ---------- | --------- | --------- |
| CSS        | 3        | 131        | 118        | 0         | 13        |
| HTML       | 1        | 53         | 52         | 0         | 1         |
| JavaScript | 2590     | 91950      | 68344      | 15700     | 7906      |
| JSX        | 2564     | 148050     | 103765     | 27614     | 16671     |
| Markdown   | 10       | 284        | 0          | 177       | 107       |
| Sass       | 195      | 5554       | 4720       | 154       | 680       |
| SVG        | 6        | 54         | 53         | 0         | 1         |
| TSX        | 679      | 28454      | 19791      | 6216      | 2447      |
| TypeScript | 894      | 42988      | 32153      | 7506      | 3329      |
| ---------- | -------- | ---------- | ---------- | --------- | --------- |
| **Total**  | **6942** | **317518** | **228996** | **57367** | **31155** |

почти все компоненты в проекте и функции следуют принципам SOLID, а именно DRY

> **Примечание:**
>
> - **SOLID** - это набор принципов объектно-ориентированного проектирования, включающий Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation и Dependency Inversion.
> - **DRY (Don't Repeat Yourself)** - принцип, направленный на снижение повторения кода.

Нам вообще зашло модное React testing library и тестировать как пользователь, аля интеграционные тесты или даже E2E. Меньше тестов меньше проблем с поддержкой.
Но получили обратное .

1. тесты стали проходить гооораздо дольше , причем на порядок. что бы получить фидбек от тестов приходится ждать очень долго.
2. если упал тест то приходится долго искать проблему. Даже просто добавили хуки или какую то функцию которую надо замокать в компоненты и все пиши пропало если ты забыл где и когда добавил, а такое бывает, потому что тесты уже запускаешь только в конце разработки так как они долгие.
3. поддержка вообще это отдельная тема. Тесты становятся хрупкими и сложными в поддержке. допустим добавили логику в одну функцию а эта функция используется везде и это везде все покрыто интеграциоными тестами. и эта функция сломалась и везде тесты тоже сломались. а это может быть до 100 тестов.
4. Писать тесты это отдельная тема. Надо или все мокать или ты будешь тестировать милион раз одно и тоже. в интеграционных тестах . Пример у нас есть формы карточек . таких карточек 100 обьектов. обьекты все разные . и везде используются инпуты и табы . но половина инпутов одинакова у них. у всех инпутов тоже есть функции которые используются везде. это запросы на бэк и валидация. и фильтрация для селектов. Получается если мы пишем интеграционные тесты то мы должны мокать все инпуты и все табы и все функции которые используются везде. Или прокликивать по настоящему тестируя одно и тоже 100 раз.
5. Огромное количество тесткейсов для хитрой логики. у нас хитрые инпуты которые завият друг от друга и в зависимости от друг друга могут быть валидными или невалидными, показыватся не показыватся , быть активными или неактивными . В общем обычная нормальная форма не из туду листа. И покрыть все это тестами интеграциоными писец очень долго и дорого не говоря о скорости выполнения. Тесты просто падают от времени выполнения приходится их дробить. Писать хаки что бы jest не падал и подождал еще немного. Далее переходим в ci/cd где тоже все падает из за того что тесты очень долго выполняются.

наша главная задача получить как можно быстрее фитбэк от тестов по поводу кода. И как мы убедились на собственном опыте интеграционные тесты не подходят для этого. Тем более E2E тесты.

### как мы решили проблему.

мы тупо перешли на юнит тесты.

1. тесты стали быстрее
2. если функция сломалась то мы быстро нашли проблему и ее исправили причем тест показал правильно и точечно.
3. тесты стали правдивее и поддержка стала легче. тест (только один :) ) точечно указывает на проблему которую надо исправить. От этого зависит как быстро мы исправим баг.
4. Писать тесты стало проще ведь одна функция одно действие. (ну так должно быть в идеале)
5. Тестируем только то что должно быть в юните. если это инпут ихтрый который зависит от другого инпута и валидации и табов то тестируем только это. А в общем проверяем что этот инпут у нас присутствует и если в него прокидываются пропсы то проверим это и все.

### Получается интеграционные тесты не нужны?

нужны.
мы на боевом проекте используем интеграционные тесты для проверки работы компонентов в целом. какой то положительный кейс проверяя что компоненты и функции собраны так как надо.

где еще я использую или где еще вижу интеграционные тесты.
это там где переиспользование дочерних функций и компонентов стремится к одному. это всяческие либы которые используются в разных проектах. библиотека Shallowly например полностью даже на E2E тестах проверяется.

## Юнит тесты должны

1. быть быстрыми
   а. в написании
   б. в выполнении  
   в. в поддержке
2. быть легкими
   а. в написании
   б. в выполнении  
   в. в поддержке
3. быть простыми
   а. в написании
   б. в выполнении  
   в. в поддержке
4. быть правдивыми (правильно показывать ошибку)
5. быть читаемыми (легко понимать что тест проверяет)

## что останавливает от написания юнит тестов.

1. не понимание как это тестировать (плохо написан код ) от сюда очень долго писать тест.
   - юнит тест должен писаться очень быстро на автомате для этого нужно понимание как работает функция и сама функция легкая по дюдюшке бобу одна функция одно действие. на самом деле писать чистый и лаконичный код намного сложнее чем выписывать френзели с патернами суя их где попао и как попало.

- ветвления, которые сложно накликать руками;
- пограничные кейсы (0, undefined, …);
- чистую бизнес-логику без DOM.

Интеграционные нужны, но они не подскажут, где именно упала функция форматирования цены, а юнит подскажет.

## Почему мы на Боевом проекте пишем юнит тесты

## Как мы пишем юнит тесты
